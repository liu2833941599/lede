diff --git a/Makefile b/Makefile
index 715c03e..4bdb566 100644
--- a/Makefile
+++ b/Makefile
@@ -25,6 +25,11 @@ ifneq ($(filter madwifi,$(IWINFO_BACKENDS)),)
 	IWINFO_LIB_OBJ += iwinfo_madwifi.o
 endif
 
+ifneq ($(filter rt,$(IWINFO_BACKENDS)),)
+	IWINFO_CFLAGS  += -DUSE_RTWIFI
+	IWINFO_LIB_OBJ += iwinfo_rtwifi.o iwinfo_rtwifi_scan.o
+endif
+
 ifneq ($(filter nl80211,$(IWINFO_BACKENDS)),)
 	IWINFO_CFLAGS      += -DUSE_NL80211
 	IWINFO_CLI_LDFLAGS += -lnl-tiny
diff --git a/api/rtwifi.h b/api/rtwifi.h
new file mode 100644
index 0000000..426a669
--- /dev/null
+++ b/api/rtwifi.h
@@ -0,0 +1,136 @@
+#ifndef __RTWIFI_H__
+#define __RTWIFI_H__
+
+#define MAC_ADDR_LENGTH	6
+#define MAX_NUMBER_OF_MAC	32
+typedef unsigned char 	UCHAR;
+typedef char		CHAR;
+typedef unsigned int	UINT32;
+typedef unsigned short	USHORT;
+typedef short		SHORT;
+typedef unsigned long	ULONG;
+
+#if WIRELESS_EXT <= 11
+#ifndef SIOCDEVPRIVATE
+#define SIOCDEVPRIVATE		0x8BE0
+#endif
+#define SIOCIWFIRSTPRIV		SIOCDEVPRIVATE
+#endif
+
+#define RTPRIV_IOCTL_SET			(SIOCIWFIRSTPRIV + 0x02)
+#define RTPRIV_IOCTL_GSITESURVEY		(SIOCIWFIRSTPRIV + 0x0D)
+#define RTPRIV_IOCTL_GET_MAC_TABLE		(SIOCIWFIRSTPRIV + 0x0F)
+#define RTPRIV_IOCTL_GET_MAC_TABLE_STRUCT	(SIOCIWFIRSTPRIV + 0x1F)
+
+#define MODE_CCK	0
+#define MODE_OFDM	1
+#define MODE_HTMIX	2
+
+/* MIMO Tx parameter, ShortGI, MCS, STBC, etc.  these are fields in TXWI. Don't change this definition!!! */
+typedef union _MACHTTRANSMIT_SETTING {
+        struct {
+                USHORT MCS:7;   /* MCS */
+                USHORT BW:1;    /*channel bandwidth 20MHz or 40 MHz */
+                USHORT ShortGI:1;
+                USHORT STBC:2;  /*SPACE */
+                USHORT rsv:3;
+                USHORT MODE:2;  /* Use definition MODE_xxx. */
+        } field;
+        USHORT word;
+} MACHTTRANSMIT_SETTING, *PMACHTTRANSMIT_SETTING;
+
+typedef struct _RT_802_11_MAC_ENTRY {
+        UCHAR ApIdx;
+        UCHAR Addr[MAC_ADDR_LENGTH];
+        UCHAR Aid;
+        UCHAR Psm;              /* 0:PWR_ACTIVE, 1:PWR_SAVE */
+        UCHAR MimoPs;           /* 0:MMPS_STATIC, 1:MMPS_DYNAMIC, 3:MMPS_Enabled */
+        CHAR AvgRssi0;
+        CHAR AvgRssi1;
+        CHAR AvgRssi2;
+        UINT32 ConnectedTime;
+        MACHTTRANSMIT_SETTING TxRate;
+        UINT32          LastRxRate;
+        SHORT           StreamSnr[3];                           /* BF SNR from RXWI. Units=0.25 dB. 22 dB offset removed */
+        SHORT           SoundingRespSnr[3];                     /* SNR from Sounding Response. Units=0.25 dB. 22 dB offset removed */
+/*      SHORT           TxPER;  */                                      /* TX PER over the last second. Percent */
+/*      SHORT           reserved;*/
+} RT_802_11_MAC_ENTRY, *PRT_802_11_MAC_ENTRY;
+
+typedef struct _RT_802_11_MAC_TABLE {
+        ULONG Num;
+        RT_802_11_MAC_ENTRY Entry[MAX_NUMBER_OF_MAC];
+} RT_802_11_MAC_TABLE, *PRT_802_11_MAC_TABLE;
+
+typedef struct _CH_FREQ_MAP_{
+	int	channel;
+	int	freqMHz;
+}CH_FREQ_MAP;
+
+CH_FREQ_MAP CH_HZ_ID_MAP[]=
+	{
+		{1, 2412},
+		{2, 2417},
+		{3, 2422},
+		{4, 2427},
+		{5, 2432},
+		{6, 2437},
+		{7, 2442},
+		{8, 2447},
+		{9, 2452},
+		{10, 2457},
+		{11, 2462},
+		{12, 2467},
+		{13, 2472},
+		{14, 2484},
+
+		/*  UNII */
+		{36, 5180},
+		{40, 5200},
+		{44, 5220},
+		{48, 5240},
+		{52, 5260},
+		{56, 5280},
+		{60, 5300},
+		{64, 5320},
+		{149, 5745},
+		{153, 5765},
+		{157, 5785},
+		{161, 5805},
+		{165, 5825},
+		{167, 5835},
+		{169, 5845},
+		{171, 5855},
+		{173, 5865},
+
+		/* HiperLAN2 */
+		{100, 5500},
+		{104, 5520},
+		{108, 5540},
+		{112, 5560},
+		{116, 5580},
+		{120, 5600},
+		{124, 5620},
+		{128, 5640},
+		{132, 5660},
+		{136, 5680},
+		{140, 5700},
+
+		/* Japan MMAC */
+		{34, 5170},
+		{38, 5190},
+		{42, 5210},
+		{46, 5230},
+
+		/*  Japan */
+		{184, 4920},
+		{188, 4940},
+		{192, 4960},
+		{196, 4980},
+
+		{208, 5040},	/* Japan, means J08 */
+		{212, 5060},	/* Japan, means J12 */   
+		{216, 5080},	/* Japan, means J16 */
+};
+
+#endif
diff --git a/include/iwinfo.h b/include/iwinfo.h
index 5e64294..f314413 100644
--- a/include/iwinfo.h
+++ b/include/iwinfo.h
@@ -257,6 +257,7 @@ void iwinfo_finish(void);
 
 extern const struct iwinfo_ops wext_ops;
 extern const struct iwinfo_ops madwifi_ops;
+extern const struct iwinfo_ops rtwifi_ops;
 extern const struct iwinfo_ops nl80211_ops;
 extern const struct iwinfo_ops wl_ops;
 
diff --git a/include/iwinfo/lua.h b/include/iwinfo/lua.h
index 8b76b25..0ebd5c5 100644
--- a/include/iwinfo/lua.h
+++ b/include/iwinfo/lua.h
@@ -37,6 +37,10 @@
 #define IWINFO_MADWIFI_META	"iwinfo.madwifi"
 #endif
 
+#ifdef USE_RTWIFI
+#define IWINFO_RTWIFI_META	"iwinfo.rtwifi"
+#endif
+
 #ifdef USE_NL80211
 #define IWINFO_NL80211_META	"iwinfo.nl80211"
 #endif
diff --git a/iwinfo_lib.c b/iwinfo_lib.c
index 7a33a35..1b8f43a 100644
--- a/iwinfo_lib.c
+++ b/iwinfo_lib.c
@@ -331,6 +331,9 @@ static const struct iwinfo_ops *backends[] = {
 #ifdef USE_MADWIFI
 	&madwifi_ops,
 #endif
+#ifdef USE_RTWIFI
+	&rtwifi_ops,
+#endif
 #ifdef USE_WL
 	&wl_ops,
 #endif
diff --git a/iwinfo_lua.c b/iwinfo_lua.c
index 58a5537..7e736cf 100644
--- a/iwinfo_lua.c
+++ b/iwinfo_lua.c
@@ -720,6 +720,36 @@ LUA_WRAP_STRUCT_OP(madwifi,mbssid_support)
 LUA_WRAP_STRUCT_OP(madwifi,hardware_id)
 #endif
 
+#ifdef USE_RTWIFI
+/* Mtk */
+LUA_WRAP_INT_OP(rtwifi,channel)
+LUA_WRAP_INT_OP(rtwifi,frequency)
+LUA_WRAP_INT_OP(rtwifi,frequency_offset)
+LUA_WRAP_INT_OP(rtwifi,txpower)
+LUA_WRAP_INT_OP(rtwifi,txpower_offset)
+LUA_WRAP_INT_OP(rtwifi,bitrate)
+LUA_WRAP_INT_OP(rtwifi,signal)
+LUA_WRAP_INT_OP(rtwifi,noise)
+LUA_WRAP_INT_OP(rtwifi,quality)
+LUA_WRAP_INT_OP(rtwifi,quality_max)
+LUA_WRAP_STRING_OP(rtwifi,ssid)
+LUA_WRAP_STRING_OP(rtwifi,bssid)
+LUA_WRAP_STRING_OP(rtwifi,country)
+LUA_WRAP_STRING_OP(rtwifi,hardware_name)
+LUA_WRAP_STRING_OP(rtwifi,phyname)
+LUA_WRAP_STRUCT_OP(rtwifi,mode)
+LUA_WRAP_STRUCT_OP(rtwifi,assoclist)
+LUA_WRAP_STRUCT_OP(rtwifi,txpwrlist)
+LUA_WRAP_STRUCT_OP(rtwifi,scanlist)
+LUA_WRAP_STRUCT_OP(rtwifi,freqlist)
+LUA_WRAP_STRUCT_OP(rtwifi,countrylist)
+LUA_WRAP_STRUCT_OP(rtwifi,hwmodelist)
+LUA_WRAP_STRUCT_OP(rtwifi,htmodelist)
+LUA_WRAP_STRUCT_OP(rtwifi,encryption)
+LUA_WRAP_STRUCT_OP(rtwifi,mbssid_support)
+LUA_WRAP_STRUCT_OP(rtwifi,hardware_id)
+#endif
+
 #ifdef USE_NL80211
 /* NL80211 */
 LUA_WRAP_INT_OP(nl80211,channel)
@@ -844,6 +874,39 @@ static const luaL_reg R_madwifi[] = {
 };
 #endif
 
+#ifdef USE_RTWIFI
+/* Mtk table */
+static const luaL_reg R_rtwifi[] = {
+	LUA_REG(rtwifi,channel),
+	LUA_REG(rtwifi,frequency),
+	LUA_REG(rtwifi,frequency_offset),
+	LUA_REG(rtwifi,txpower),
+	LUA_REG(rtwifi,txpower_offset),
+	LUA_REG(rtwifi,bitrate),
+	LUA_REG(rtwifi,signal),
+	LUA_REG(rtwifi,noise),
+	LUA_REG(rtwifi,quality),
+	LUA_REG(rtwifi,quality_max),
+	LUA_REG(rtwifi,mode),
+	LUA_REG(rtwifi,ssid),
+	LUA_REG(rtwifi,bssid),
+	LUA_REG(rtwifi,country),
+	LUA_REG(rtwifi,assoclist),
+	LUA_REG(rtwifi,txpwrlist),
+	LUA_REG(rtwifi,scanlist),
+	LUA_REG(rtwifi,freqlist),
+	LUA_REG(rtwifi,countrylist),
+	LUA_REG(rtwifi,hwmodelist),
+	LUA_REG(rtwifi,htmodelist),
+	LUA_REG(rtwifi,encryption),
+	LUA_REG(rtwifi,mbssid_support),
+	LUA_REG(rtwifi,hardware_id),
+	LUA_REG(rtwifi,hardware_name),
+	LUA_REG(rtwifi,phyname),
+	{ NULL, NULL }
+};
+#endif
+
 #ifdef USE_NL80211
 /* NL80211 table */
 static const luaL_reg R_nl80211[] = {
@@ -937,6 +1000,15 @@ LUALIB_API int luaopen_iwinfo(lua_State *L) {
 	lua_setfield(L, -2, "madwifi");
 #endif
 
+#ifdef USE_RTWIFI
+	luaL_newmetatable(L, IWINFO_RTWIFI_META);
+	luaL_register(L, NULL, R_common);
+	luaL_register(L, NULL, R_rtwifi);
+	lua_pushvalue(L, -1);
+	lua_setfield(L, -2, "__index");
+	lua_setfield(L, -2, "rtwifi");
+#endif
+
 #ifdef USE_NL80211
 	luaL_newmetatable(L, IWINFO_NL80211_META);
 	luaL_register(L, NULL, R_common);
diff --git a/iwinfo_rtwifi.c b/iwinfo_rtwifi.c
new file mode 100644
index 0000000..af7abac
--- /dev/null
+++ b/iwinfo_rtwifi.c
@@ -0,0 +1,400 @@
+#include "iwinfo_wext.h"
+#include "api/rtwifi.h"
+
+struct survey_table {
+	long channel;
+	long strength;
+	char mode[12];
+	char ssid[66];
+	char bssid[18];
+	char enc[16];
+	char crypto[16];
+};
+
+static int rtwifi_wrq(struct iwreq *wrq, const char *ifname, int cmd, void *data, size_t len)
+{
+	strncpy(wrq->ifr_name, ifname, IFNAMSIZ);
+
+	if( data != NULL )
+	{
+		if( len < IFNAMSIZ )
+		{
+			memcpy(wrq->u.name, data, len);
+		}
+		else
+		{
+			wrq->u.data.pointer = data;
+			wrq->u.data.length = len;
+		}
+	}
+
+	return iwinfo_ioctl(cmd, wrq);
+}
+
+static int rtwifi_get80211priv(const char *ifname, int op, void *data, size_t len)
+{
+	struct iwreq iwr;
+
+	if( rtwifi_wrq(&iwr, ifname, op, data, len) < 0 )
+		return -1;
+
+	return iwr.u.data.length;
+}
+
+static int rtwifi_isap(const char *ifname)
+{
+	int ret=0;
+
+	if( strlen(ifname) <= 7 )
+	{
+		static char wifiname[IFNAMSIZ];
+		snprintf(wifiname, sizeof(wifiname), "%s", ifname);
+		if( !strncmp(wifiname, "ra", 2) || !strncmp(wifiname, "rai", 3) ) ret=1;
+	}
+
+	return ret;
+}
+
+static int rtwifi_iscli(const char *ifname)
+{
+	int ret=0;
+
+	if( strlen(ifname) <= 7 )
+	{
+		static char wifiname[IFNAMSIZ];
+		snprintf(wifiname, sizeof(wifiname), "%s", ifname);
+		if( !strncmp(wifiname, "apcli", 5) || !strncmp(wifiname, "apclii", 6) ) ret=1;
+	}
+
+	return ret;
+}
+
+static int rtwifi_probe(const char *ifname)
+{
+	return ( rtwifi_isap(ifname) || rtwifi_iscli(ifname) );
+}
+
+static void rtwifi_close(void)
+{
+	/* Nop */
+}
+
+static int rtwifi_get_mode(const char *ifname, int *buf)
+{
+	if( rtwifi_isap(ifname) ) *buf = IWINFO_OPMODE_MASTER;
+	else if( rtwifi_iscli(ifname) ) *buf = IWINFO_OPMODE_CLIENT;
+	else *buf = IWINFO_OPMODE_UNKNOWN;
+	return 0;
+}
+
+static int rtwifi_get_ssid(const char *ifname, char *buf)
+{
+	return wext_ops.ssid(ifname, buf);
+}
+
+static int rtwifi_get_bssid(const char *ifname, char *buf)
+{
+	return wext_ops.bssid(ifname, buf);
+}
+
+static int rtwifi_get_bitrate(const char *ifname, int *buf)
+{
+	return wext_ops.bitrate(ifname, buf);
+}
+
+static int rtwifi_get_channel(const char *ifname, int *buf)
+{
+	return wext_ops.channel(ifname, buf);
+}
+
+static int rtwifi_get_frequency(const char *ifname, int *buf)
+{
+	int channel,chidx,chnum;
+
+	chnum=(sizeof(CH_HZ_ID_MAP)/sizeof(CH_FREQ_MAP));
+
+	if(rtwifi_get_channel(ifname, &channel) >= 0);
+	{
+		for (chidx = 0; chidx < chnum; chidx++)
+		{
+			if (channel == CH_HZ_ID_MAP[chidx].channel)
+			{
+				*buf = CH_HZ_ID_MAP[chidx].freqMHz;
+				return 0;
+			}
+		}
+	}
+	return -1;
+}
+
+static int rtwifi_get_txpower(const char *ifname, int *buf)
+{
+	return wext_ops.txpower(ifname, buf);
+}
+
+static int rtwifi_get_signal(const char *ifname, int *buf)
+{
+	return wext_ops.signal(ifname, buf);
+}
+
+static int rtwifi_get_noise(const char *ifname, int *buf)
+{
+	return wext_ops.noise(ifname, buf);
+}
+
+static int rtwifi_get_quality(const char *ifname, int *buf)
+{
+	return wext_ops.quality(ifname, buf);
+}
+
+static int rtwifi_get_quality_max(const char *ifname, int *buf)
+{
+	return wext_ops.quality_max(ifname, buf);
+}
+
+static int rtwifi_get_rate(MACHTTRANSMIT_SETTING HTSetting)
+
+{
+	int MCSMappingRateTable[] =
+	{2,  4,   11,  22, /* CCK*/
+	12, 18,   24,  36, 48, 72, 96, 108, /* OFDM*/
+	13, 26,   39,  52,  78, 104, 117, 130, 26,  52,  78, 104, 156, 208, 234, 260, /* 20MHz, 800ns GI, MCS: 0 ~ 15*/
+	39, 78,  117, 156, 234, 312, 351, 390,										  /* 20MHz, 800ns GI, MCS: 16 ~ 23*/
+	27, 54,   81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540, /* 40MHz, 800ns GI, MCS: 0 ~ 15*/
+	81, 162, 243, 324, 486, 648, 729, 810,										  /* 40MHz, 800ns GI, MCS: 16 ~ 23*/
+	14, 29,   43,  57,  87, 115, 130, 144, 29, 59,   87, 115, 173, 230, 260, 288, /* 20MHz, 400ns GI, MCS: 0 ~ 15*/
+	43, 87,  130, 173, 260, 317, 390, 433,										  /* 20MHz, 400ns GI, MCS: 16 ~ 23*/
+	30, 60,   90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600, /* 40MHz, 400ns GI, MCS: 0 ~ 15*/
+	90, 180, 270, 360, 540, 720, 810, 900};
+
+	int rate_count = sizeof(MCSMappingRateTable)/sizeof(int);
+	int rate_index = 0;
+	int value = 0;
+
+	if (HTSetting.field.MODE >= MODE_HTMIX)
+	{
+    		rate_index = 12 + ((UCHAR)HTSetting.field.BW *24) + ((UCHAR)HTSetting.field.ShortGI *48) + ((UCHAR)HTSetting.field.MCS);
+	}
+	else if (HTSetting.field.MODE == MODE_OFDM)
+		rate_index = (UCHAR)(HTSetting.field.MCS) + 4;
+	else if (HTSetting.field.MODE == MODE_CCK)   
+		rate_index = (UCHAR)(HTSetting.field.MCS);
+
+	if (rate_index < 0)
+		rate_index = 0;
+    
+	if (rate_index >= rate_count)
+		rate_index = rate_count-1;
+
+	value = (MCSMappingRateTable[rate_index] * 5)/10;
+
+	return value;
+}
+
+static int rtwifi_get_assoclist(const char *ifname, char *buf, int *len)
+{
+	struct iwinfo_assoclist_entry entry;
+	RT_802_11_MAC_TABLE *mt;
+	MACHTTRANSMIT_SETTING rxrate;
+	char raname[IFNAMSIZ],raidx[IFNAMSIZ],raiidx[IFNAMSIZ];
+	int mtlen=sizeof(RT_802_11_MAC_TABLE);
+	int i,j;
+
+	if ((mt = (RT_802_11_MAC_TABLE *) malloc(mtlen)) == NULL)
+	{
+		return -1;
+	}
+
+	memset(mt, 0, mtlen);
+	snprintf(raname, sizeof(raname), "%s", ifname);
+
+	if (rtwifi_get80211priv(ifname, RTPRIV_IOCTL_GET_MAC_TABLE_STRUCT, mt, mtlen) > 0)
+	{
+		j = 0;
+
+		for (i = 0; i < mt->Num; i++)
+		{
+			snprintf(raidx, sizeof(raidx), "ra%d", mt->Entry[i].ApIdx);
+			snprintf(raiidx, sizeof(raiidx), "rai%d", mt->Entry[i].ApIdx);
+
+			if( strncmp(raname, raidx, IFNAMSIZ) && strncmp(raname, raiidx, IFNAMSIZ) ) continue;
+
+			memset(&entry, 0, sizeof(entry));
+
+			memcpy(entry.mac, &mt->Entry[i].Addr, 6);
+
+			if(mt->Entry[i].AvgRssi0 > mt->Entry[i].AvgRssi1)
+				entry.signal = mt->Entry[i].AvgRssi0;
+			else
+				entry.signal = mt->Entry[i].AvgRssi1;
+
+			entry.noise  = -95;
+
+			entry.inactive = mt->Entry[i].ConnectedTime * 1000;
+
+			rxrate.word = mt->Entry[i].LastRxRate;
+			entry.tx_rate.rate = rtwifi_get_rate(mt->Entry[i].TxRate) * 1000;
+			entry.rx_rate.rate = rtwifi_get_rate(rxrate) * 1000;
+
+			entry.tx_rate.mcs = mt->Entry[i].TxRate.field.MCS;
+			entry.rx_rate.mcs = rxrate.field.MCS;
+
+			entry.tx_packets = 0;
+			entry.rx_packets = 0;
+
+			if(mt->Entry[i].TxRate.field.BW) entry.tx_rate.is_40mhz = 1;
+			if(mt->Entry[i].TxRate.field.ShortGI) entry.tx_rate.is_short_gi = 1;
+			if(rxrate.field.BW) entry.rx_rate.is_40mhz = 1;
+			if(rxrate.field.ShortGI) entry.rx_rate.is_short_gi = 1;
+
+			memcpy(&buf[j], &entry, sizeof(struct iwinfo_assoclist_entry));
+			j += sizeof(struct iwinfo_assoclist_entry);
+		}
+		*len = j;
+		free(mt);
+		return 0;
+	}
+
+	free(mt);
+	return -1;
+}
+
+static int rtwifi_get_txpwrlist(const char *ifname, char *buf, int *len)
+{
+	wext_ops.txpwrlist(ifname, buf, len);
+}
+
+static int rtwifi_get_freqlist(const char *ifname, char *buf, int *len)
+{
+	return -1;
+}
+
+static int rtwifi_get_country(const char *ifname, char *buf)
+{
+	sprintf(buf, "00");
+	return 0;
+}
+
+static int rtwifi_get_countrylist(const char *ifname, char *buf, int *len)
+{
+	/* Stub */
+	return -1;
+}
+
+static int rtwifi_get_hwmodelist(const char *ifname, int *buf)
+{
+	return -1;
+}
+
+static int rtwifi_get_htmodelist(const char *ifname, int *buf)
+{
+	return -1;
+}
+
+static int rtwifi_get_encryption(const char *ifname, char *buf)
+{
+	/* No reliable crypto info in mtk */
+	return -1;
+}
+
+static int rtwifi_get_phyname(const char *ifname, char *buf)
+{
+	/* No suitable api in mtk */
+	strcpy(buf, ifname);
+	return 0;
+}
+
+static int rtwifi_get_mbssid_support(const char *ifname, int *buf)
+{
+	return -1;
+}
+
+static int rtwifi_get_hardware_id(const char *ifname, char *buf)
+{
+	char vendor[64];
+	char device[64];
+	struct iwinfo_hardware_id *ids;
+	struct iwinfo_hardware_entry *e;
+
+	if (wext_ops.hardware_id(ifname, buf))
+		return iwinfo_hardware_id_from_mtd((struct iwinfo_hardware_id *)buf);
+
+	return 0;
+}
+
+static const struct iwinfo_hardware_entry *
+rtwifi_get_hardware_entry(const char *ifname)
+{
+	struct iwinfo_hardware_id id;
+
+	if (rtwifi_get_hardware_id(ifname, (char *)&id))
+		return NULL;
+
+	return iwinfo_hardware(&id);
+}
+
+static int rtwifi_get_hardware_name(const char *ifname, char *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+
+	if (!(hw = rtwifi_get_hardware_entry(ifname)))
+		sprintf(buf, "Generic Mediatek/Ralink");
+	else
+		sprintf(buf, "%s %s", hw->vendor_name, hw->device_name);
+
+	return 0;
+}
+
+static int rtwifi_get_txpower_offset(const char *ifname, int *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+
+	if (!(hw = rtwifi_get_hardware_entry(ifname)))
+		return -1;
+
+	*buf = hw->txpower_offset;
+	return 0;
+}
+
+static int rtwifi_get_frequency_offset(const char *ifname, int *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+
+	if (!(hw = rtwifi_get_hardware_entry(ifname)))
+		return -1;
+
+	*buf = hw->frequency_offset;
+	return 0;
+}
+
+const struct iwinfo_ops rtwifi_ops = {
+	.name             = "rtwifi",
+	.probe            = rtwifi_probe,
+	.channel          = rtwifi_get_channel,
+	.frequency        = rtwifi_get_frequency,
+	.frequency_offset = rtwifi_get_frequency_offset,
+	.txpower          = rtwifi_get_txpower,
+	.txpower_offset   = rtwifi_get_txpower_offset,
+	.bitrate          = rtwifi_get_bitrate,
+	.signal           = rtwifi_get_signal,
+	.noise            = rtwifi_get_noise,
+	.quality          = rtwifi_get_quality,
+	.quality_max      = rtwifi_get_quality_max,
+	.mbssid_support   = rtwifi_get_mbssid_support,
+	.hwmodelist       = rtwifi_get_hwmodelist,
+	.htmodelist       = rtwifi_get_htmodelist,
+	.mode             = rtwifi_get_mode,
+	.ssid             = rtwifi_get_ssid,
+	.bssid            = rtwifi_get_bssid,
+	.country          = rtwifi_get_country,
+	.hardware_id      = rtwifi_get_hardware_id,
+	.hardware_name    = rtwifi_get_hardware_name,
+	.encryption       = rtwifi_get_encryption,
+	.phyname          = rtwifi_get_phyname,
+	.assoclist        = rtwifi_get_assoclist,
+	.txpwrlist        = rtwifi_get_txpwrlist,
+	.scanlist         = rtwifi_get_scanlist,
+	.freqlist         = rtwifi_get_freqlist,
+	.countrylist      = rtwifi_get_countrylist,
+	.close            = rtwifi_close
+};
diff --git a/iwinfo_rtwifi_scan.c b/iwinfo_rtwifi_scan.c
new file mode 100644
index 0000000..1c601d8
--- /dev/null
+++ b/iwinfo_rtwifi_scan.c
@@ -0,0 +1,136 @@
+#include "iwinfo.h"
+#include "iwinfo_wext.h"
+
+struct survey_table
+{
+	char channel[4];
+	char ssid[33];
+	char bssid[20];
+	char security[23];
+	char *crypto;
+	char signal[6];
+};
+
+struct survey_table st[64];
+int survey_count = 0;
+
+#define RTPRIV_IOCTL_SET (SIOCIWFIRSTPRIV + 0x02)
+void iwpriv(const char *name, const char *key, const char *val)
+{
+	int socket_id;
+	struct iwreq wrq;
+	char data[64];
+	snprintf(data, 64, "%s=%s", key, val);
+	socket_id = socket(AF_INET, SOCK_DGRAM, 0);
+	strcpy(wrq.ifr_ifrn.ifrn_name, name);
+	wrq.u.data.length = strlen(data);
+	wrq.u.data.pointer = data;
+	wrq.u.data.flags = 0;
+	ioctl(socket_id, RTPRIV_IOCTL_SET, &wrq);
+	close(socket_id);
+}
+
+static void next_field(char **line, char *output, int n) {
+	char *l = *line;
+	int i;
+
+	memcpy(output, *line, n);
+	*line = &l[n];
+
+	for (i = n - 1; i > 0; i--) {
+		if (output[i] != ' ')
+			break;
+		output[i] = '\0';
+	}
+}
+
+#define RTPRIV_IOCTL_GSITESURVEY (SIOCIWFIRSTPRIV + 0x0D)
+void wifi_site_survey(const char *ifname, char* essid, int print)
+{
+	char *s = malloc(IW_SCAN_MAX_DATA);
+	int ret;
+	int socket_id;
+	struct iwreq wrq;
+	char *line, *start;
+	iwpriv(ifname, "SiteSurvey", (essid ? essid : ""));
+	sleep(5);
+	memset(s, 0x00, IW_SCAN_MAX_DATA);
+	strcpy(wrq.ifr_name, ifname);
+	wrq.u.data.length = IW_SCAN_MAX_DATA;
+	wrq.u.data.pointer = s;
+	wrq.u.data.flags = 0;
+	socket_id = socket(AF_INET, SOCK_DGRAM, 0);
+	ret = ioctl(socket_id, RTPRIV_IOCTL_GSITESURVEY, &wrq);
+	close(socket_id);
+	if(ret != 0)
+		goto out;
+	if(wrq.u.data.length < 1)
+		goto out;
+	/* ioctl result starts with a newline, for some reason */
+	start = s;
+	while (*start == '\n')
+		start++;
+	line = strtok((char *)start, "\n");
+	line = strtok(NULL, "\n");
+	survey_count = 0;
+	while(line && (survey_count < 64)) {
+		next_field(&line, st[survey_count].channel, sizeof(st->channel));
+		next_field(&line, st[survey_count].ssid, sizeof(st->ssid));
+		next_field(&line, st[survey_count].bssid, sizeof(st->bssid));
+		next_field(&line, st[survey_count].security, sizeof(st->security));
+		next_field(&line, st[survey_count].signal, sizeof(st->signal));
+		line = strtok(NULL, "\n");
+		st[survey_count].crypto = strstr(st[survey_count].security, "/");
+		if (st[survey_count].crypto) {
+			*st[survey_count].crypto = '\0';
+			st[survey_count].crypto++;
+			if (print) printf("%s|%s|%s|%s\n",
+				st[survey_count].channel, st[survey_count].ssid, st[survey_count].bssid, st[survey_count].security);
+		}
+		survey_count++;
+	}
+	if (survey_count == 0 && !print)
+		printf("No results");
+out:
+	free(s);
+}
+
+int rtwifi_get_scanlist(const char *ifname, char *buf, int *len)
+{
+	struct iwinfo_scanlist_entry *e = (struct iwinfo_scanlist_entry *) buf;
+	int i = 0;
+
+	survey_count = 0;
+
+	wifi_site_survey(ifname, NULL, 0);
+
+	for (i = 0; i < survey_count; i++) {
+		int j;
+		for (j = 0; j < 6; j++) {
+			e[i].mac[j] = (uint8_t) strtoul(&st[i].bssid[j * 3], NULL, 16);
+		}
+		strcpy(e[i].ssid, st[i].ssid);
+		e[i].channel = atoi(st[i].channel);
+		e[i].mode = IWINFO_OPMODE_MASTER;
+		e[i].quality = atoi(st[i].signal);
+		e[i].quality_max = 100;
+		memset(&e[i].crypto, 0, sizeof(struct iwinfo_crypto_entry));
+		if (strstr(st[i].security, "WPA")) {
+			e[i].crypto.enabled = 1;
+			e[i].crypto.auth_suites |= IWINFO_KMGMT_PSK;
+		}
+		if (!st[i].crypto)
+			continue;
+		if (strstr(st[i].crypto, "TKIP"))
+			e[i].crypto.group_ciphers |= IWINFO_CIPHER_TKIP;
+		if (strstr(st[i].crypto, "AES"))
+			e[i].crypto.group_ciphers |= IWINFO_CIPHER_AESOCB;
+		if (strstr(st[i].security, "WPA2"))
+			e[i].crypto.wpa_version = 2;
+		else if (strstr(st[i].security, "WPA"))
+			e[i].crypto.wpa_version = 1;
+	}
+	*len = survey_count * sizeof(struct iwinfo_scanlist_entry);
+
+	return 0;
+}
diff --git a/iwinfo_wext.h b/iwinfo_wext.h
index 6896450..14f3f22 100644
--- a/iwinfo_wext.h
+++ b/iwinfo_wext.h
@@ -379,4 +379,8 @@ static const unsigned int standard_event_num =
 
 int wext_get_scanlist(const char *ifname, char *buf, int *len);
 
+#ifdef USE_RTWIFI
+int rtwifi_get_scanlist(const char *ifname, char *buf, int *len);
+#endif
+
 #endif
